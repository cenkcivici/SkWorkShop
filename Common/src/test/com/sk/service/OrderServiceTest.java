package com.sk.service;import java.util.Arrays;import java.util.List;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.mockito.Mock;import org.mockito.invocation.InvocationOnMock;import org.mockito.runners.MockitoJUnitRunner;import org.mockito.stubbing.Answer;import com.sk.domain.Order;import com.sk.domain.OrderStatus;import com.sk.domain.PaymentMethod;import com.sk.domain.Shopper;import com.sk.domain.ShoppingCart;import com.sk.domain.dao.OrderDao;import com.sk.service.payment.ResponseStatus;import com.sk.service.payment.VPOSResponse;import com.sk.service.payment.garanti.GarantiVPOSService;import com.sk.util.builder.CreditCardPaymentMethodBuilder;import com.sk.util.builder.OrderBuilder;import com.sk.util.builder.ShopperBuilder;import com.sk.util.builder.ShoppingCartBuilder;import static org.mockito.Mockito.verify;import static org.mockito.Mockito.verifyNoMoreInteractions;import static org.mockito.Mockito.when;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.equalTo;import static org.hamcrest.Matchers.hasItem;import static org.mockito.Matchers.anyObject;@RunWith(MockitoJUnitRunner.class)public class OrderServiceTest {	private OrderService orderService;		@Mock	private OrderDao orderDao;		@Mock	private ShopperService shopperService;		@Mock	private GarantiVPOSService garantiVPOSService;	@Before	public void init() {		orderService = new OrderService(orderDao,shopperService,garantiVPOSService);	}		@Test	public void shouldGetByShopperReturnsAllOrdersByShopper(){		Order order = new OrderBuilder().build();		List<Order> ordersByShopper = Arrays.asList(order);		Shopper shopper = new ShopperBuilder().build();		when(orderDao.findByShopper(shopper)).thenReturn(ordersByShopper);				List<Order> orders = orderService.getAllByShopper(shopper);		assertThat(orders,hasItem(order));	}	@Test	public void shouldCreateAndPersistOrder() {		when(orderDao.persist((Order) anyObject())).then(new Answer<Order>() {			@Override			public Order answer(InvocationOnMock invocation) throws Throwable {				return (Order) invocation.getArguments()[0];			}		});				Shopper shopper = new ShopperBuilder().build();		when(shopperService.getStubShopper()).thenReturn(shopper);						ShoppingCart shoppingCart = new ShoppingCartBuilder().build();		PaymentMethod paymentMethod = new CreditCardPaymentMethodBuilder().build();		Order order = orderService.createOrder(shoppingCart, paymentMethod);				assertThat(order.getPaymentMethod(), equalTo(paymentMethod));		assertThat(order.getShoppingCart(), equalTo(shoppingCart));		assertThat(order.getShopper(),equalTo(shopper));	}		@Test	public void shouldPersistOrderWithUnderReviewStatus(){		ShoppingCart shoppingCart = new ShoppingCartBuilder().build();		PaymentMethod paymentMethod = new CreditCardPaymentMethodBuilder().build();				Order order = orderService.createOrder(shoppingCart, paymentMethod);		assertThat(order.getOrderStatus(), equalTo(OrderStatus.UNDERREVIEW));	}		@Test	public void shouldApproveRefundRequestUpdatesOrderIfRefundIsSuccessful(){		Order order = new OrderBuilder().build();		when(garantiVPOSService.refundOrder(order)).thenReturn(new VPOSResponse(ResponseStatus.SUCCESS));		orderService.approveRefundRequest(order);				verify(orderDao).persist(order);		assertThat(order.getOrderStatus(), equalTo(OrderStatus.REFUND_ACCEPTED));	}		@Test	public void shouldApproveRefundRequestDoesNOTUpdatesOrderIfRefundIsNotSuccessful(){		Order order = new OrderBuilder().orderStatus(OrderStatus.REFUND_REQUESTED).build();		when(garantiVPOSService.refundOrder(order)).thenReturn(new VPOSResponse(ResponseStatus.FAILURE));				orderService.approveRefundRequest(order);				verifyNoMoreInteractions(orderDao);		assertThat(order.getOrderStatus(), equalTo(OrderStatus.REFUND_REQUESTED));	}}